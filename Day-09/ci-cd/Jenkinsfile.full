pipeline {
  agent any
  environment {
    DOCKER_USERNAME = "toktechteam"
    BACKEND_IMAGE = "${DOCKER_USERNAME}/student-backend"
    FRONTEND_IMAGE = "${DOCKER_USERNAME}/student-frontend"
    // Deployment configuration
    DEPLOY_LOCAL = "true"  // Set to "true" to deploy locally, "false" to skip
    DEPLOY_REMOTE = "true" // Set to "true" to deploy to EC2, "false" to skip
    EC2_USER = "ec2-user"
    EC2_IP = "your-ec2-ip" // Replace with your EC2 instance IP
    EC2_SSH_CREDS = "ec2-ssh-key" // Jenkins credential ID for SSH private key
  }

  stages {
    stage('Install Dependencies') {
      steps {
        sh 'cd $WORKSPACE/backend && npm install && npm install --save-dev jest jest-junit'
      }
    }

    stage('Run Tests') {
      steps {
        sh 'cd $WORKSPACE/backend/__tests__/ && npm test'
      }
    }

    stage('Run Tests with Coverage') {
      steps {
        sh 'cd $WORKSPACE/backend && npm test -- --coverage'
      }
    }

    stage('SonarQube Analysis') {
      steps {
        script {
          def scannerCheck = sh(script: 'which sonar-scanner || echo "NOT_FOUND"', returnStdout: true).trim()

          if (scannerCheck == "NOT_FOUND") {
            echo "SonarQube Scanner not found in PATH. Please install it or add it to PATH."
            currentBuild.result = 'UNSTABLE'
          } else {
            sh '''
              if [ ! -f "$WORKSPACE/backend/sonar-project.properties" ]; then
                echo "# Required metadata" > $WORKSPACE/backend/sonar-project.properties
                echo "sonar.projectKey=student-backend" >> $WORKSPACE/backend/sonar-project.properties
                echo "sonar.projectName=Student Backend" >> $WORKSPACE/backend/sonar-project.properties
                echo "sonar.projectVersion=1.0.0" >> $WORKSPACE/backend/sonar-project.properties
                echo "" >> $WORKSPACE/backend/sonar-project.properties
                echo "# Path to source directories" >> $WORKSPACE/backend/sonar-project.properties
                echo "sonar.sources=." >> $WORKSPACE/backend/sonar-project.properties
                echo "sonar.exclusions=node_modules/**,coverage/**,__tests__/**" >> $WORKSPACE/backend/sonar-project.properties
                echo "" >> $WORKSPACE/backend/sonar-project.properties
                echo "# Path to test directories" >> $WORKSPACE/backend/sonar-project.properties
                echo "sonar.tests=__tests__" >> $WORKSPACE/backend/sonar-project.properties
                echo "sonar.test.inclusions=**/*.test.js" >> $WORKSPACE/backend/sonar-project.properties
                echo "" >> $WORKSPACE/backend/sonar-project.properties
                echo "# Source encoding" >> $WORKSPACE/backend/sonar-project.properties
                echo "sonar.sourceEncoding=UTF-8" >> $WORKSPACE/backend/sonar-project.properties
                echo "" >> $WORKSPACE/backend/sonar-project.properties
                echo "# Coverage reports" >> $WORKSPACE/backend/sonar-project.properties
                echo "sonar.javascript.lcov.reportPaths=coverage/lcov.info" >> $WORKSPACE/backend/sonar-project.properties
              fi
            '''

            withSonarQubeEnv('SonarLocal') {
              sh 'cd $WORKSPACE/backend && sonar-scanner || echo "SonarQube analysis failed"'
            }
          }
        }
      }
    }

    stage('Build Backend Image') {
      steps {
        sh 'docker build -t $BACKEND_IMAGE:latest -f $WORKSPACE/docker/Dockerfile.backend .'
      }
    }

    stage('Build Frontend Image') {
      steps {
        sh 'docker build -t $FRONTEND_IMAGE:latest -f $WORKSPACE/docker/Dockerfile.frontend .'
      }
    }

    stage('Scan Both Images') {
      steps {
        sh '''
          trivy image $BACKEND_IMAGE:latest --format json --output $WORKSPACE/trivy-backend-report.json || echo "Trivy scan for backend failed but continuing"
          trivy image $FRONTEND_IMAGE:latest --format json --output $WORKSPACE/trivy-frontend-report.json || echo "Trivy scan for frontend failed but continuing"
        '''
      }
    }

    stage('Archive Reports') {
      steps {
        archiveArtifacts artifacts: '**/coverage/lcov.info, $WORKSPACE/trivy-*.json', fingerprint: true, allowEmptyArchive: true
      }
    }

    stage('Push to Docker Hub') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'docker-hub-creds', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
          sh '''
            echo $DOCKER_PASS | docker login -u $DOCKER_USER --password-stdin
            docker push $BACKEND_IMAGE:latest
            docker push $FRONTEND_IMAGE:latest
          '''
        }
      }
    }

    stage('Update Docker Compose for Deployment') {
      steps {
        script {
          // Temporarily modify the docker-compose.yaml to use the pushed Docker Hub images
          sh '''
            # Create a backup of the original docker-compose.yaml
            cp $WORKSPACE/docker/docker-compose.yaml $WORKSPACE/docker/docker-compose.yaml.bak

            # Replace the build directives with image references in the docker-compose.yaml
            sed -i 's|build:\\n      context: .\\n      dockerfile: ./Dockerfile.backend|image: ${BACKEND_IMAGE}:latest|g' $WORKSPACE/docker/docker-compose.yaml
            sed -i 's|build:\\n      context: .\\n      dockerfile: ./Dockerfile.frontend|image: ${FRONTEND_IMAGE}:latest|g' $WORKSPACE/docker/docker-compose.yaml

            # Print the modified docker-compose.yaml for verification
            echo "Modified docker-compose.yaml for deployment:"
            cat $WORKSPACE/docker/docker-compose.yaml
          '''
        }
      }
    }

    stage('Deploy to Same Server') {
      when {
        expression { return env.DEPLOY_LOCAL == 'true' }
      }
      steps {
        sh '''
          # Navigate to the workspace directory
          cd $WORKSPACE

          # Stop existing containers if they exist
          docker-compose -f docker/docker-compose.yaml down || true

          # Start new containers
          docker-compose -f docker/docker-compose.yaml up -d

          # Verify deployment
          echo "Checking if containers are running..."
          docker ps | grep student-management-backend
          docker ps | grep student-management-frontend
        '''
      }
    }

    stage('Deploy to EC2') {
      when {
        expression { return env.DEPLOY_REMOTE == 'true' }
      }
      steps {
        withCredentials([sshUserPrivateKey(credentialsId: "${EC2_SSH_CREDS}", keyFileVariable: 'KEY_FILE'), usernamePassword(credentialsId: 'docker-hub-creds', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
          sh '''
            # Create deployment directory on EC2 if it doesn't exist
            ssh -i $KEY_FILE -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_IP} "mkdir -p ~/student-deployment"

            # Copy needed files to EC2
            scp -i $KEY_FILE -o StrictHostKeyChecking=no $WORKSPACE/docker/docker-compose.yaml ${EC2_USER}@${EC2_IP}:~/student-deployment/
            scp -i $KEY_FILE -o StrictHostKeyChecking=no $WORKSPACE/database/setup.sql ${EC2_USER}@${EC2_IP}:~/student-deployment/

            # Create database directory if it doesn't exist
            ssh -i $KEY_FILE -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_IP} "mkdir -p ~/student-deployment/database"

            # Move files to their correct locations
            ssh -i $KEY_FILE -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_IP} "
              mv ~/student-deployment/setup.sql ~/student-deployment/database/
            "

            # Deploy on EC2
            ssh -i $KEY_FILE -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_IP} "
              # Login to Docker Hub to pull the images
              echo \"${DOCKER_PASS}\" | docker login -u ${DOCKER_USER} --password-stdin

              # Change to deployment directory
              cd ~/student-deployment

              # Stop existing containers if they exist
              docker-compose down || true

              # Pull latest images
              docker pull ${BACKEND_IMAGE}:latest
              docker pull ${FRONTEND_IMAGE}:latest

              # Start new containers
              docker-compose up -d

              # Verify deployment
              echo 'Checking if containers are running...'
              docker ps | grep student-management-backend
              docker ps | grep student-management-frontend
            "
          '''
        }
      }
    }
  }

  post {
    always {
      // Restore original docker-compose.yaml file
      sh '''
        if [ -f "$WORKSPACE/docker/docker-compose.yaml.bak" ]; then
          mv $WORKSPACE/docker/docker-compose.yaml.bak $WORKSPACE/docker/docker-compose.yaml
        fi
      '''

      junit allowEmptyResults: true, testResults: '$WORKSPACE/backend/test-results/**/*.xml'

      // Clean up Docker images to prevent disk space issues
      sh '''
        if [ "${DEPLOY_LOCAL}" != "true" ]; then
          docker-compose -f $WORKSPACE/docker/docker-compose.yaml down || true
          docker rmi $BACKEND_IMAGE:latest || true
          docker rmi $FRONTEND_IMAGE:latest || true
        fi
      '''
    }
    success {
      echo 'Pipeline successfully completed!'
    }
    failure {
      echo 'Pipeline failed. Please check the logs for details.'
    }
  }
}